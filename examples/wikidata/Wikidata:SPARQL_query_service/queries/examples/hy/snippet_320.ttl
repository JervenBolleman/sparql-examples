@prefix ex: <https://sparql.uniprot.org/.well-known/sparql-examples/> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix schema: <https://schema.org/> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix wiki: <https://www.wikidata.org/wiki/> .

ex:sparqlrdf/Wikidata:SPARQL_query_service/queries/examples/hy/snippet_320.ttl a sh:SPARQLExecutable,
        sh:SPARQLSelectExecutable ;
    rdfs:comment "Sparql query from file sparqlrdf/Wikidata:SPARQL_query_service/queries/examples/hy/snippet_320.ttl"^^rdf:HTML ;
    dcterms:license <https://creativecommons.org/licenses/by-sa/4.0/> ;
    dcterms:isVersionOf <https://www.wikidata.org/wiki/Wikidata:SPARQL_query_service/queries/examples/hy> ;
    sh:select """
PREFIX wd: <http://www.wikidata.org/entity/>
PREFIX wds: <http://www.wikidata.org/entity/statement/>
PREFIX wdv: <http://www.wikidata.org/value/>
PREFIX wdt: <http://www.wikidata.org/prop/direct/>
PREFIX wikibase: <http://wikiba.se/ontology#>
PREFIX p: <http://www.wikidata.org/prop/>
PREFIX ps: <http://www.wikidata.org/prop/statement/>
PREFIX pq: <http://www.wikidata.org/prop/qualifier/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX bd: <http://www.bigdata.com/rdf#>

PREFIX wdref: <http://www.wikidata.org/reference/>
PREFIX psv: <http://www.wikidata.org/prop/statement/value/>
PREFIX psn: <http://www.wikidata.org/prop/statement/value-normalized/>
PREFIX pqv: <http://www.wikidata.org/prop/qualifier/value/>
PREFIX pqn: <http://www.wikidata.org/prop/qualifier/value-normalized/>
PREFIX pr: <http://www.wikidata.org/prop/reference/>
PREFIX prv: <http://www.wikidata.org/prop/reference/value/>
PREFIX prn: <http://www.wikidata.org/prop/reference/value-normalized/>
PREFIX wdno: <http://www.wikidata.org/prop/novalue/>
PREFIX wdata: <http://www.wikidata.org/wiki/Special:EntityData/>

PREFIX schema: <http://schema.org/>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX prov: <http://www.w3.org/ns/prov#>
PREFIX bds: <http://www.bigdata.com/rdf/search#>
PREFIX gas: <http://www.bigdata.com/rdf/gas#>
PREFIX hint: <http://www.bigdata.com/queryHints#>



# Each composer’s most used tonality, with number of works in that tonality.
# (If this is ambiguous – multiple tonalities with the same number – there are multiple results for one composer.)
#
# The SPARQL for this is an evil perversion of three subqueries (one of them nested in another).
# To understand it, you have to go inside out… follow the numbers.

SELECT ?composerLabel ?tonalityLabel ?count
WHERE
{
  {
    # 4. Group again, this time just by the composer.
    #    We also select the highest count of a tonality.
    #    Notice that we don’t know what tonality this count is associated with – we’ll get to that.
    #    So now we have each composer, along with how often they used whatever tonality they used most.
    SELECT ?composer (MAX(?count) AS ?count_)
    WHERE
    {
      {
        # 2. Group by composer and tonality, so that for each composer and tonality, we get a count of how often the composer used this tonality.
        SELECT ?composer ?tonality (COUNT(?composition) AS ?count)
        WHERE
        {
          # 1. Extremely straightforward: the ?composition has the composer ?composer and the tonality ?tonality.
          #    (I’m not bothering with any “instance of” because the presence of these two properties is a sufficient indicator of ?composition being a composition.)
          ?composition wdt:P86 ?composer;
                       wdt:P826 ?tonality.
        }
        GROUP BY ?composer ?tonality
        HAVING(?count > 1) # 3. Limit that to counts > 1, because using a tonality once is hardly “most used”.
      }
    }
    GROUP BY ?composer
  }
  {
    # 6. Identical to 2.
    SELECT ?composer ?tonality (COUNT(?composition) AS ?count)
    WHERE
    {
      # 5. Identical to 1.
      ?composition wdt:P86 ?composer;
                   wdt:P826 ?tonality.
    }
    GROUP BY ?composer ?tonality
    HAVING(?count > 1) # 7. Identical to 3.
  }
  # 8. That’s it. Wait, what?
  #    From 4, we now have ?composer, any composer, and ?count, the count of how often they used whatever tonality they used most.
  #    From 6, we also have a ?composer, as well as a ?tonality, and the count of how often they used that particular tonality.
  #    The trick is that ?composer and ?count are the same variable in each subquery, and so now, when the two subqueries are joined,
  #    we select only that ?tonality from 6 where the ?composer and the ?count are identical to those from 4 –
  #    that is, where this tonality was used as often as the composer’s most-used tonality.
  #    In other words, this must *be* the composer’s most-used tonality (except when there are multiple tonalities with the same count).
  SERVICE wikibase:label { bd:serviceParam wikibase:language "en". }
}
ORDER BY DESC(?count) # 9. Order by count (highest first), because the result isn’t very meaningful for low counts (many compositions aren’t on Wikidata or don’t have a tonality statement).

""" ;
    schema:target <https://query.wikidata.org/sparql/> .
